# MiniTerm - Utilities and Demos

This section describes the simple utilities and demo programs that are included
with the mini_term gem. The applications are designed to ease writing and
testing of programs using mini_term. Then again, some are just for fun.

## mapped_key_test

The mapped_key_test program is designed demonstrate the mapped input system.
The program comes with sample mappings for the supported systems and supports
the use of alternate maps as well.

If no arguments are given, the default maps are used.
The following shows a sample run with an input of "1234567890 Enter UpArrow
LeftArrow RightArrow DownArrow Tab Ctrl+z" with the default map under Windows.

    42 mysh>mapped_key_test

    Testing Mapped Keyboard input. Press Ctrl+z to quit.
    Current maps = [:windows, :ansi]
    Current term type = :windows

    action = :insert_text, text = ["1"]
    action = :insert_text, text = ["2"]
    action = :insert_text, text = ["3"]
    action = :insert_text, text = ["4"]
    action = :insert_text, text = ["5"]
    action = :insert_text, text = ["6"]
    action = :insert_text, text = ["7"]
    action = :insert_text, text = ["8"]
    action = :insert_text, text = ["9"]
    action = :insert_text, text = ["0"]
    action = :enter, text = ["\r"]
    action = :previous_history, text = ["\xE0", "H"]
    action = :go_left, text = ["\xE0", "K"]
    action = :go_right, text = ["\xE0", "M"]
    action = :next_history, text = ["\xE0", "P"]
    action = :auto_complete, text = ["\t"]
    action = :end_of_input, text = ["\u001A"]

Alternatively, the path(s) to a Ruby file(s) containing maps can be provided.
One such file is provided at samples/test_map.rb. this trivial map shows a
custom map in action.

    43 mysh>mapped_key_test samples\test_map.rb
    Requiring 'C:/Sites/mini_term/samples/test_map.rb'

    Testing Mapped Keyboard input. Press Ctrl+z to quit.
    Current maps = [:windows, :ansi]
    Current term type = :windows

    action = :unmapped, text = ["1"]
    action = :unmapped, text = ["2"]
    action = :unmapped, text = ["3"]
    action = :unmapped, text = ["4"]
    action = :unmapped, text = ["5"]
    action = :unmapped, text = ["6"]
    action = :unmapped, text = ["7"]
    action = :unmapped, text = ["8"]
    action = :unmapped, text = ["9"]
    action = :unmapped, text = ["0"]
    action = :unmapped, text = ["\t"]
    action = :end_of_input, text = ["\u001A"]

As mentioned before, this map doesn't do much but it does illustrate the basics
of creating a custom map.

## mini_term_blizzard

The other programs bundled with mini_term are serious practical utilities. They
all serve a purpose. The mini_term_blizzard is none of those things! When run,
it fills the console screen with _snow_.

Yup!

Snow!

If run with no arguments, it uses the asterisk ("*") for the snowflakes. It can
also take hex arguments that are the code point, or range of code points to be
used. The following looks really nice on my test machine:

    mini_term_blizzard 2740 2749

## mini_term_code_points

The purpose of the mini_term_code_points is to explore the glyphs associated
with the code points of characters sent to the console. Let's see what plain
old ASCII looks like:

    16 mysh>mini_term_code_points 20 7F
    Code points in the range: 20...7F
       0                                       !"#$%&' ()*+,-./ 01234567 89:;<=>?
      40  @ABCDEFG HIJKLMNO PQRSTUVW XYZ[\]^_ `abcdefg hijklmno pqrstuvw xyz{|}~

While the other demo programs make direct use of the mini term gem, this one
does not. It simply allows the programmer to explore the extent of Unicode
support in the test environment.

Note: By default, the mini_term_code_points displays the first 65536 code
points which can take a while and will probably scroll away unless you pipe
it into more (or less) or have a deep scroll back buffer.

## raw_key_test

This program is intended as a means to explore the key codes generated by the
keyboard. This will help in the process of designing a MiniTerm map or the
custom code to directly handle user input.

The program works by taking raw data from the keyboard and simply displaying it
in hex format. The program exits when the character "Q" is entered.

A sample run of this program, under Windows is shown below. In this example the
keys entered were "1234567890 *F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12* qQ"
where *F1* through *F12* represent the keyboard's "F" keys and spaces are added
only for clarity and where not entered.

    77 mysh>raw_key_test
    Testing Raw Keyboard input. Press Q to quit.
    [31][32][33][34][35][36][37][38][39][30][00][3B][00][3C][00][3D][00][3E][00][3F]
    [00][40][00][41][00][42][00][43][00][44][E0][85][E0][86][71][51]
